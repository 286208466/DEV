```js
/**
 * @param {string} input value
 * @returns {number} output value
 */
export function byteLength(str) {
  // returns the byte length of an utf8 string
  let s = str.length;
  for (var i = str.length - 1; i >= 0; i--) {
    const code = str.charCodeAt(i);
    if (code > 0x7f && code <= 0x7ff) s++;
    else if (code > 0x7ff && code <= 0xffff) s += 2;
    if (code >= 0xdc00 && code <= 0xdfff) i--;
  }
  return s;
}

/**
 * @param {Array} actual
 * @returns {Array}
 */
export function cleanArray(actual) {
  const newArray = [];
  for (let i = 0; i < actual.length; i++) {
    if (actual[i]) {
      newArray.push(actual[i]);
    }
  }
  return newArray;
}

/**
 * @param {Object} json
 * @returns {Array}
 */
export function param(json) {
  if (!json) return "";
  return cleanArray(
    Object.keys(json).map((key) => {
      if (json[key] === undefined) return "";
      return encodeURIComponent(key) + "=" + encodeURIComponent(json[key]);
    })
  ).join("&");
}

/**
 * @param {string} url
 * @returns {Object}
 */
export function param2Obj(url) {
  const search = decodeURIComponent(url.split("?")[1]).replace(/\+/g, " ");
  if (!search) {
    return {};
  }
  const obj = {};
  const searchArr = search.split("&");
  searchArr.forEach((v) => {
    const index = v.indexOf("=");
    if (index !== -1) {
      const name = v.substring(0, index);
      const val = v.substring(index + 1, v.length);
      obj[name] = val;
    }
  });
  return obj;
}

/**
 * Merges two objects, giving the last one precedence
 * @param {Object} target
 * @param {(Object|Array)} source
 * @returns {Object}
 */
export function objectMerge(target, source) {
  if (typeof target !== "object") {
    target = {};
  }
  if (Array.isArray(source)) {
    return source.slice();
  }
  Object.keys(source).forEach((property) => {
    const sourceProperty = source[property];
    if (typeof sourceProperty === "object") {
      target[property] = objectMerge(target[property], sourceProperty);
    } else {
      target[property] = sourceProperty;
    }
  });
  return target;
}

/**
 * @param {Function} func
 * @param {number} wait
 * @param {boolean} immediate
 * @return {*}
 */
export function debounce(func, wait, immediate) {
  let timeout, args, context, timestamp, result;

  const later = function() {
    // 据上一次触发时间间隔
    const last = +new Date() - timestamp;

    // 上次被包装函数被调用时间间隔 last 小于设定时间间隔 wait
    if (last < wait && last > 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      }
    }
  };

  return function(...args) {
    context = this;
    timestamp = +new Date();
    const callNow = immediate && !timeout;
    // 如果延时不存在，重新设定延时
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };
}

/**
 * This is just a simple version of deep copy
 * Has a lot of edge cases bug
 * If you want to use a perfect deep copy, use lodash's _.cloneDeep
 * @param {Object} source
 * @returns {Object}
 */
export function deepClone(source) {
  if (!source && typeof source !== "object") {
    throw new Error("error arguments", "deepClone");
  }
  const targetObj = source.constructor === Array ? [] : {};
  Object.keys(source).forEach((keys) => {
    if (source[keys] && typeof source[keys] === "object") {
      targetObj[keys] = deepClone(source[keys]);
    } else {
      targetObj[keys] = source[keys];
    }
  });
  return targetObj;
}

/**
 * @returns {string}
 */
export function createUniqueString() {
  const timestamp = +new Date() + "";
  const randomNum = parseInt((1 + Math.random()) * 65536) + "";
  return (+(randomNum + timestamp)).toString(32);
}

/**
 * @param {string} url
 * @returns {Object}
 */
export function getQueryObject(url) {
  url = url == null ? window.location.href : url;
  const search = url.substring(url.lastIndexOf("?") + 1);
  const obj = {};
  const reg = /([^?&=]+)=([^?&=]*)/g;
  search.replace(reg, (rs, $1, $2) => {
    const name = decodeURIComponent($1);
    let val = decodeURIComponent($2);
    val = String(val);
    obj[name] = val;
    return rs;
  });
  return obj;
}

/**
 *Created by PanJiaChen on 16/11/29.
 * @param {Sting} url
 * @param {Sting} title
 * @param {Number} w
 * @param {Number} h
 */
export default function openWindow(url, title, w, h) {
  // Fixes dual-screen position                            Most browsers       Firefox
  const dualScreenLeft =
    window.screenLeft !== undefined ? window.screenLeft : screen.left;
  const dualScreenTop =
    window.screenTop !== undefined ? window.screenTop : screen.top;

  const width = window.innerWidth
    ? window.innerWidth
    : document.documentElement.clientWidth
    ? document.documentElement.clientWidth
    : screen.width;
  const height = window.innerHeight
    ? window.innerHeight
    : document.documentElement.clientHeight
    ? document.documentElement.clientHeight
    : screen.height;

  const left = width / 2 - w / 2 + dualScreenLeft;
  const top = height / 2 - h / 2 + dualScreenTop;
  const newWindow = window.open(
    url,
    title,
    "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=" +
      w +
      ", height=" +
      h +
      ", top=" +
      top +
      ", left=" +
      left
  );

  // Puts focus on the newWindow
  if (window.focus) {
    newWindow.focus();
  }
}

Math.easeInOutQuad = function(t, b, c, d) {
  t /= d / 2;
  if (t < 1) {
    return (c / 2) * t * t + b;
  }
  t--;
  return (-c / 2) * (t * (t - 2) - 1) + b;
};

// requestAnimationFrame for Smart Animating http://goo.gl/sx5sts
var requestAnimFrame = (function() {
  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
    }
  );
})();

/**
 * Because it's so fucking difficult to detect the scrolling element, just move them all
 * @param {number} amount
 */
function move(amount) {
  document.documentElement.scrollTop = amount;
  document.body.parentNode.scrollTop = amount;
  document.body.scrollTop = amount;
}

function position() {
  return (
    document.documentElement.scrollTop ||
    document.body.parentNode.scrollTop ||
    document.body.scrollTop
  );
}

/**
 * @param {number} to
 * @param {number} duration
 * @param {Function} callback
 */
export function scrollTo(to, duration, callback) {
  const start = position();
  const change = to - start;
  const increment = 20;
  let currentTime = 0;
  duration = typeof duration === "undefined" ? 500 : duration;
  var animateScroll = function() {
    // increment the time
    currentTime += increment;
    // find the value with the quadratic in-out easing function
    var val = Math.easeInOutQuad(currentTime, start, change, duration);
    // move the document.body
    move(val);
    // do the animation unless its over
    if (currentTime < duration) {
      requestAnimFrame(animateScroll);
    } else {
      if (callback && typeof callback === "function") {
        // the animation is done so lets callback
        callback();
      }
    }
  };
  animateScroll();
}



/**
 * @param {string} val
 * @returns {string}
 */
export function html2Text(val) {
  const div = document.createElement("div");
  div.innerHTML = val;
  return div.textContent || div.innerText;
}
//返回顶部
export function goTop() {
  /*(function smoothscroll(){  
			var currentScroll = document.documentElement.scrollTop || document.body.scrollTop;  
			if(currentScroll > 0){  
				window.requestAnimationFrame(smoothscroll);  
				window.scrollTo (0, currentScroll - (currentScroll/5));  
			}  
		})();  */
  window
    .$("html, body")
    .stop()
    .animate(
      {
        scrollTop: 0,
      },
      300
    );
}

/**
 * 得到一个元素的left坐标值.
 * @param {dom对象} obj
 * @return {位置值}
 */

export function getLeft(e) {
  var offset = e.offsetLeft;
  if (e.offsetParent != null) offset += getLeft(e.offsetParent);
  return offset;
}

/**
 * 得到一个元素的绝对位置的top坐标值.
 * @param {dom对象} obj
 * @return {位置值}
 */

export function getTop(e) {
  var offset = e.offsetTop;
  if (e.offsetParent != null) offset += getTop(e.offsetParent);
  return offset;
}


//数字转成人民币格式
/*
 * example:convertCurrency(123456)
 * */
function convertCurrency(currencyDigits) {  
	// Constants:  
	var MAXIMUM_NUMBER = 99999999999.99;  
	// Predefine the radix characters and currency symbols for output:  
	var CN_ZERO = "零";  
	var CN_ONE = "壹";  
	var CN_TWO = "贰";  
	var CN_THREE = "叁";  
	var CN_FOUR = "肆";  
	var CN_FIVE = "伍";  
	var CN_SIX = "陆";  
	var CN_SEVEN = "柒";  
	var CN_EIGHT = "捌";  
	var CN_NINE = "玖";  
	var CN_TEN = "拾";  
	var CN_HUNDRED = "佰";  
	var CN_THOUSAND = "仟";  
	var CN_TEN_THOUSAND = "万";  
	var CN_HUNDRED_MILLION = "亿";  
	var CN_SYMBOL = "人民币";  
	var CN_DOLLAR = "元";  
	var CN_TEN_CENT = "角";  
	var CN_CENT = "分";  
	var CN_INTEGER = "整";  
	  
	// Variables:  
	var integral; // Represent integral part of digit number.  
	var decimal; // Represent decimal part of digit number.  
	var outputCharacters; // The output result.  
	var parts;  
	var digits, radices, bigRadices, decimals;  
	var zeroCount;  
	var i, p, d;  
	var quotient, modulus;  
	  
	// Validate input string:  
	currencyDigits = currencyDigits.toString();  
	if (currencyDigits == "") {  
		alert("Empty input!");  
		return "";  
	}  
	if (currencyDigits.match(/[^,.\d]/) != null) {  
		alert("Invalid characters in the input string!");  
		return "";  
	}  
	if ((currencyDigits).match(/^((\d{1,3}(,\d{3})*(.((\d{3},)*\d{1,3}))?)|(\d+(.\d+)?))$/) == null) {  
		alert("Illegal format of digit number!");  
		return "";  
	}  
	  
	// Normalize the format of input digits:  
	currencyDigits = currencyDigits.replace(/,/g, ""); // Remove comma delimiters.  
	currencyDigits = currencyDigits.replace(/^0+/, ""); // Trim zeros at the beginning.  
	// Assert the number is not greater than the maximum number.  
	if (Number(currencyDigits) > MAXIMUM_NUMBER) {  
		alert("Too large a number to convert!");  
		return "";  
	}  
	  
	// Process the coversion from currency digits to characters:  
	// Separate integral and decimal parts before processing coversion:  
	parts = currencyDigits.split(".");  
	if (parts.length > 1) {  
		integral = parts[0];  
		decimal = parts[1];  
		// Cut down redundant decimal digits that are after the second.  
		decimal = decimal.substr(0, 2);  
	}  
	else {  
		integral = parts[0];  
		decimal = "";  
	}  
	// Prepare the characters corresponding to the digits:  
	digits = new Array(CN_ZERO, CN_ONE, CN_TWO, CN_THREE, CN_FOUR, CN_FIVE, CN_SIX, CN_SEVEN, CN_EIGHT, CN_NINE);  
	radices = new Array("", CN_TEN, CN_HUNDRED, CN_THOUSAND);  
	bigRadices = new Array("", CN_TEN_THOUSAND, CN_HUNDRED_MILLION);  
	decimals = new Array(CN_TEN_CENT, CN_CENT);  
	// Start processing:  
	outputCharacters = "";  
	// Process integral part if it is larger than 0:  
	if (Number(integral) > 0) {  
		zeroCount = 0;  
		for (i = 0; i < integral.length; i++) {  
			p = integral.length - i - 1;  
			d = integral.substr(i, 1);  
			quotient = p / 4;  
			modulus = p % 4;  
			if (d == "0") {  
				zeroCount++;  
			}  
			else {  
				if (zeroCount > 0)  
				{  
					outputCharacters += digits[0];  
				}  
				zeroCount = 0;  
				outputCharacters += digits[Number(d)] + radices[modulus];  
			}  
			if (modulus == 0 && zeroCount < 4) {  
				outputCharacters += bigRadices[quotient];  
			}  
		}  
		outputCharacters += CN_DOLLAR;  
	}  
	// Process decimal part if there is:  
	if (decimal != "") {  
		for (i = 0; i < decimal.length; i++) {  
			d = decimal.substr(i, 1);  
			if (d != "0") {  
				outputCharacters += digits[Number(d)] + decimals[i];  
			}  
		}  
	}  
	// Confirm and return the final output string:  
	if (outputCharacters == "") {  
		outputCharacters = CN_ZERO + CN_DOLLAR;  
	}  
	if (decimal == "") {  
		outputCharacters += CN_INTEGER;  
	}  
	return outputCharacters;  
} 


/**
 * @param {string} input value
 * @returns {number} output value
 */
export function byteLength(str) {
  // returns the byte length of an utf8 string
  let s = str.length;
  for (var i = str.length - 1; i >= 0; i--) {
    const code = str.charCodeAt(i);
    if (code > 0x7f && code <= 0x7ff) s++;
    else if (code > 0x7ff && code <= 0xffff) s += 2;
    if (code >= 0xdc00 && code <= 0xdfff) i--;
  }
  return s;
}

/**
 * @param {Array} actual
 * @returns {Array}
 */
export function cleanArray(actual) {
  const newArray = [];
  for (let i = 0; i < actual.length; i++) {
    if (actual[i]) {
      newArray.push(actual[i]);
    }
  }
  return newArray;
}

/**
 * @param {Object} json
 * @returns {Array}
 */
export function param(json) {
  if (!json) return "";
  return cleanArray(
    Object.keys(json).map((key) => {
      if (json[key] === undefined) return "";
      return encodeURIComponent(key) + "=" + encodeURIComponent(json[key]);
    })
  ).join("&");
}

/**
 * @param {string} url
 * @returns {Object}
 */
export function param2Obj(url) {
  const search = decodeURIComponent(url.split("?")[1]).replace(/\+/g, " ");
  if (!search) {
    return {};
  }
  const obj = {};
  const searchArr = search.split("&");
  searchArr.forEach((v) => {
    const index = v.indexOf("=");
    if (index !== -1) {
      const name = v.substring(0, index);
      const val = v.substring(index + 1, v.length);
      obj[name] = val;
    }
  });
  return obj;
}

/**
 * Merges two objects, giving the last one precedence
 * @param {Object} target
 * @param {(Object|Array)} source
 * @returns {Object}
 */
export function objectMerge(target, source) {
  if (typeof target !== "object") {
    target = {};
  }
  if (Array.isArray(source)) {
    return source.slice();
  }
  Object.keys(source).forEach((property) => {
    const sourceProperty = source[property];
    if (typeof sourceProperty === "object") {
      target[property] = objectMerge(target[property], sourceProperty);
    } else {
      target[property] = sourceProperty;
    }
  });
  return target;
}

/**
 * @param {Function} func
 * @param {number} wait
 * @param {boolean} immediate
 * @return {*}
 */
export function debounce(func, wait, immediate) {
  let timeout, args, context, timestamp, result;

  const later = function() {
    // 据上一次触发时间间隔
    const last = +new Date() - timestamp;

    // 上次被包装函数被调用时间间隔 last 小于设定时间间隔 wait
    if (last < wait && last > 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      }
    }
  };

  return function(...args) {
    context = this;
    timestamp = +new Date();
    const callNow = immediate && !timeout;
    // 如果延时不存在，重新设定延时
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };
}

/**
 * This is just a simple version of deep copy
 * Has a lot of edge cases bug
 * If you want to use a perfect deep copy, use lodash's _.cloneDeep
 * @param {Object} source
 * @returns {Object}
 */
export function deepClone(source) {
  if (!source && typeof source !== "object") {
    throw new Error("error arguments", "deepClone");
  }
  const targetObj = source.constructor === Array ? [] : {};
  Object.keys(source).forEach((keys) => {
    if (source[keys] && typeof source[keys] === "object") {
      targetObj[keys] = deepClone(source[keys]);
    } else {
      targetObj[keys] = source[keys];
    }
  });
  return targetObj;
}

/**
 * @returns {string}
 */
export function createUniqueString() {
  const timestamp = +new Date() + "";
  const randomNum = parseInt((1 + Math.random()) * 65536) + "";
  return (+(randomNum + timestamp)).toString(32);
}

/**
 * @param {string} url
 * @returns {Object}
 */
export function getQueryObject(url) {
  url = url == null ? window.location.href : url;
  const search = url.substring(url.lastIndexOf("?") + 1);
  const obj = {};
  const reg = /([^?&=]+)=([^?&=]*)/g;
  search.replace(reg, (rs, $1, $2) => {
    const name = decodeURIComponent($1);
    let val = decodeURIComponent($2);
    val = String(val);
    obj[name] = val;
    return rs;
  });
  return obj;
}

/**
 *Created by PanJiaChen on 16/11/29.
 * @param {Sting} url
 * @param {Sting} title
 * @param {Number} w
 * @param {Number} h
 */
export default function openWindow(url, title, w, h) {
  // Fixes dual-screen position                            Most browsers       Firefox
  const dualScreenLeft =
    window.screenLeft !== undefined ? window.screenLeft : screen.left;
  const dualScreenTop =
    window.screenTop !== undefined ? window.screenTop : screen.top;

  const width = window.innerWidth
    ? window.innerWidth
    : document.documentElement.clientWidth
    ? document.documentElement.clientWidth
    : screen.width;
  const height = window.innerHeight
    ? window.innerHeight
    : document.documentElement.clientHeight
    ? document.documentElement.clientHeight
    : screen.height;

  const left = width / 2 - w / 2 + dualScreenLeft;
  const top = height / 2 - h / 2 + dualScreenTop;
  const newWindow = window.open(
    url,
    title,
    "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=" +
      w +
      ", height=" +
      h +
      ", top=" +
      top +
      ", left=" +
      left
  );

  // Puts focus on the newWindow
  if (window.focus) {
    newWindow.focus();
  }
}

Math.easeInOutQuad = function(t, b, c, d) {
  t /= d / 2;
  if (t < 1) {
    return (c / 2) * t * t + b;
  }
  t--;
  return (-c / 2) * (t * (t - 2) - 1) + b;
};

// requestAnimationFrame for Smart Animating http://goo.gl/sx5sts
var requestAnimFrame = (function() {
  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
    }
  );
})();

/**
 * Because it's so fucking difficult to detect the scrolling element, just move them all
 * @param {number} amount
 */
function move(amount) {
  document.documentElement.scrollTop = amount;
  document.body.parentNode.scrollTop = amount;
  document.body.scrollTop = amount;
}

function position() {
  return (
    document.documentElement.scrollTop ||
    document.body.parentNode.scrollTop ||
    document.body.scrollTop
  );
}

/**
 * @param {number} to
 * @param {number} duration
 * @param {Function} callback
 */
export function scrollTo(to, duration, callback) {
  const start = position();
  const change = to - start;
  const increment = 20;
  let currentTime = 0;
  duration = typeof duration === "undefined" ? 500 : duration;
  var animateScroll = function() {
    // increment the time
    currentTime += increment;
    // find the value with the quadratic in-out easing function
    var val = Math.easeInOutQuad(currentTime, start, change, duration);
    // move the document.body
    move(val);
    // do the animation unless its over
    if (currentTime < duration) {
      requestAnimFrame(animateScroll);
    } else {
      if (callback && typeof callback === "function") {
        // the animation is done so lets callback
        callback();
      }
    }
  };
  animateScroll();
}















//检测浏览器，如果是ie7、ie6 显示提示升级浏览器信息
export function updateIE() {
  var browser = navigator.appName;
  if (browser == "Microsoft Internet Explorer") {
    var b_version = navigator.appVersion;
    var version = b_version.split(";");
    var trim_Version = version[1].replace(/[ ]/g, "");
    if (trim_Version == "MSIE7.0" || trim_Version == "MSIE6.0") {
      window.location.href = "../../system/ie.html";
    }
  }
}







/*
-------------------------------------------------------
base64加密解密
-------------------------------------------------------
var _base64 = function(){

    var self = this;

    // private property
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    // public method for encoding
    this.encode = function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = self._utf8_encode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output +
                _keyStr.charAt(enc1) + _keyStr.charAt(enc2) +
                _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output;
    }

    // public method for decoding
    this.decode = function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }
        }
        output = self._utf8_decode(output);
        return output;
    }

    // private method for UTF-8 encoding
    this._utf8_encode = function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }
        return utftext;
    }

    // private method for UTF-8 decoding
    this._utf8_decode = function (utftext) {
        var string = "";
        var i = 0;
        var c = 0;
        var c1 = 0;
        var c2 = 0;
        var c3 = 0;
        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            } else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            } else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }
        return string;
    }
};
//base64加密
function encrypt(str){
	var base64 = new _base64();
    var encrypt = base64.encode(str);
    return encrypt;
}
//base64解密
function decrypt(str){
	var base64 = new _base64();
    var decrypt = base64.decode(str);
    decrypt = escape(decrypt);
    decrypt = decrypt.replace(/%00/g, '');
    decrypt = unescape(decrypt);
    return decrypt;
}
*/

/*
-------------------------------------------------------
解决不支持Object.create
-------------------------------------------------------
if (!Object.create) {
    Object.create = function(o, properties) {
        if (typeof o !== 'object' && typeof o !== 'function') throw new TypeError('Object prototype may only be an Object: ' + o);
    else if (o === null) throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");

    if (typeof properties != 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");

        function F() {}

        F.prototype = o;

        return new F();
    };
}

(function() {
	var testObject = {};
	if (!(Object.setPrototypeOf || testObject.__proto__)) {
		var nativeGetPrototypeOf = Object.getPrototypeOf;

		Object.getPrototypeOf = function(object) {
			if (object.__proto__) {
				return object.__proto__;
			} else {
				return nativeGetPrototypeOf.call(Object, object);
			}
		}
	}
})();
*/

```


```js







/**
 * @description                       将函数转成防抖动函数
 * @param  {Function}                 需要转成防抖动函数的函数
 * @param  {number}                   延迟时间（毫秒数）
 * @param  {boolean}                  是否执行第一次
 * @return {undefined}                无返回值
 */
export function debounce(fn, delay = 600, runFirstFn = true) {
  let timer = null;

  return function (...rest) {
    // 清除定时器
    clearTimeout(timer);
    if (runFirstFn) {
      fn.apply(this, rest);
      runFirstFn = false;
      return;
    }

    // 设置定时器
    timer = setTimeout(fn.bind(this, ...rest), delay);
  };
}


// 防抖 且首次执行
// 采用原理：第一操作触发，连续操作时，最后一次操作打开任务开关（并非执行任务），任务将在下一次操作时触发）
export function debounceStart(fn, delay, ctx) {
  let immediate = true 
  let movement = null
  return function() {
      let args = arguments
      
      // 开关打开时，执行任务
      if (immediate) {
          fn.apply(ctx, args)
          immediate = false
      }
      // 清空上一次操作
      clearTimeout(movement)
      
      // 任务开关打开
      movement = setTimeout(function() {
          immediate = true
      }, delay)
  }
}

// 防抖 尾部执行
// 采用原理：连续操作时，上次设置的setTimeout被clear掉
export function debounceTail(fn, delay, ctx) {
  let movement = null
  return function() {
      let args = arguments
      
      // 清空上一次操作
      clearTimeout(movement)
      
      // delay时间之后，任务执行
      movement = setTimeout(function() {
          fn.apply(ctx, args)
      }, delay)
  }
}

// 限频，每delay的时间执行一次 
export function throttle(fn, delay, ctx) {
  let isAvail = true
  return function() {
      let args = arguments
      
      // 开关打开时，执行任务
      if (isAvail) {
          fn.apply(ctx, args)
          isAvail = false
          
          // delay时间之后，任务开关打开
          setTimeout(function() {
              isAvail = true
          }, delay)
      }
  }
}
```


```js
/**
 * @param {Array} arr
 * @returns {Array}
 */
export function uniqueArr(arr) {
  return Array.from(new Set(arr));
}


/**
 * 判断dom对象是否包含某个class
 * 
*/
export function hasClass(el, cName) {
  return !!el.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}

/**
 * 给dom对象添加某个class
 * 
*/
export function addClass(el, cName) {
  if (!hasClass(el, cName)) {
    el.className += " " + cName;
  }
}

/**
 * 删除dom对象的某个class
 * 
*/
export function removeClass(el, cName) {
  if (hasClass(el, cName)) {
    el.className = el.className.replace(
      new RegExp("(\\s|^)" + cName + "(\\s|$)"),
      " "
    );
  }
}

/**
 * @param {HTMLElement} element
 * @param {string} className
 */
export function toggleClass(element, className) {
  if (!element || !className) {
    return;
  }
  let classString = element.className;
  const nameIndex = classString.indexOf(className);
  if (nameIndex === -1) {
    classString += "" + className;
  } else {
    classString =
      classString.substr(0, nameIndex) +
      classString.substr(nameIndex + className.length);
  }
  element.className = classString;
}


//iframe下载文件
export function download(filepath) {
  var iframe = document.getElementById("downloadframe");
  if (iframe) {
    iframe.src = filepath;
  } else {
    iframe = document.createElement("iframe");
    iframe.src = filepath;
    iframe.style.display = "none";
    iframe.id = "downloadframe";
    document.body.appendChild(iframe);
  }
}


/**
 * @param {string} val
 * @returns {string}
 */
export function html2Text(val) {
  const div = document.createElement("div");
  div.innerHTML = val;
  return div.textContent || div.innerText;
}
//返回顶部
export function goTop() {
  /*(function smoothscroll(){  
			var currentScroll = document.documentElement.scrollTop || document.body.scrollTop;  
			if(currentScroll > 0){  
				window.requestAnimationFrame(smoothscroll);  
				window.scrollTo (0, currentScroll - (currentScroll/5));  
			}  
		})();  */
  window
    .$("html, body")
    .stop()
    .animate(
      {
        scrollTop: 0,
      },
      300
    );
}

/**
 * 得到一个元素的left坐标值.
 * @param {dom对象} obj
 * @return {位置值}
 */

export function getLeft(e) {
  var offset = e.offsetLeft;
  if (e.offsetParent != null) offset += getLeft(e.offsetParent);
  return offset;
}

/**
 * 得到一个元素的绝对位置的top坐标值.
 * @param {dom对象} obj
 * @return {位置值}
 */

export function getTop(e) {
  var offset = e.offsetTop;
  if (e.offsetParent != null) offset += getTop(e.offsetParent);
  return offset;
}


/**
 * @param {string} str
 * @returns {Boolean}
 */
export function isString(str) {
  if (typeof str === "string" || str instanceof String) {
    return true;
  }
  return false;
}

/**
 * @param {Array} arg
 * @returns {Boolean}
 */
export function isArray(arg) {
  if (typeof Array.isArray === "undefined") {
    return Object.prototype.toString.call(arg) === "[object Array]";
  }
  return Array.isArray(arg);
}


//数字转成人民币格式
/*
 * example:convertCurrency(123456)
 * */
function convertCurrency(currencyDigits) {  
	// Constants:  
	var MAXIMUM_NUMBER = 99999999999.99;  
	// Predefine the radix characters and currency symbols for output:  
	var CN_ZERO = "零";  
	var CN_ONE = "壹";  
	var CN_TWO = "贰";  
	var CN_THREE = "叁";  
	var CN_FOUR = "肆";  
	var CN_FIVE = "伍";  
	var CN_SIX = "陆";  
	var CN_SEVEN = "柒";  
	var CN_EIGHT = "捌";  
	var CN_NINE = "玖";  
	var CN_TEN = "拾";  
	var CN_HUNDRED = "佰";  
	var CN_THOUSAND = "仟";  
	var CN_TEN_THOUSAND = "万";  
	var CN_HUNDRED_MILLION = "亿";  
	var CN_SYMBOL = "人民币";  
	var CN_DOLLAR = "元";  
	var CN_TEN_CENT = "角";  
	var CN_CENT = "分";  
	var CN_INTEGER = "整";  
	  
	// Variables:  
	var integral; // Represent integral part of digit number.  
	var decimal; // Represent decimal part of digit number.  
	var outputCharacters; // The output result.  
	var parts;  
	var digits, radices, bigRadices, decimals;  
	var zeroCount;  
	var i, p, d;  
	var quotient, modulus;  
	  
	// Validate input string:  
	currencyDigits = currencyDigits.toString();  
	if (currencyDigits == "") {  
		alert("Empty input!");  
		return "";  
	}  
	if (currencyDigits.match(/[^,.\d]/) != null) {  
		alert("Invalid characters in the input string!");  
		return "";  
	}  
	if ((currencyDigits).match(/^((\d{1,3}(,\d{3})*(.((\d{3},)*\d{1,3}))?)|(\d+(.\d+)?))$/) == null) {  
		alert("Illegal format of digit number!");  
		return "";  
	}  
	  
	// Normalize the format of input digits:  
	currencyDigits = currencyDigits.replace(/,/g, ""); // Remove comma delimiters.  
	currencyDigits = currencyDigits.replace(/^0+/, ""); // Trim zeros at the beginning.  
	// Assert the number is not greater than the maximum number.  
	if (Number(currencyDigits) > MAXIMUM_NUMBER) {  
		alert("Too large a number to convert!");  
		return "";  
	}  
	  
	// Process the coversion from currency digits to characters:  
	// Separate integral and decimal parts before processing coversion:  
	parts = currencyDigits.split(".");  
	if (parts.length > 1) {  
		integral = parts[0];  
		decimal = parts[1];  
		// Cut down redundant decimal digits that are after the second.  
		decimal = decimal.substr(0, 2);  
	}  
	else {  
		integral = parts[0];  
		decimal = "";  
	}  
	// Prepare the characters corresponding to the digits:  
	digits = new Array(CN_ZERO, CN_ONE, CN_TWO, CN_THREE, CN_FOUR, CN_FIVE, CN_SIX, CN_SEVEN, CN_EIGHT, CN_NINE);  
	radices = new Array("", CN_TEN, CN_HUNDRED, CN_THOUSAND);  
	bigRadices = new Array("", CN_TEN_THOUSAND, CN_HUNDRED_MILLION);  
	decimals = new Array(CN_TEN_CENT, CN_CENT);  
	// Start processing:  
	outputCharacters = "";  
	// Process integral part if it is larger than 0:  
	if (Number(integral) > 0) {  
		zeroCount = 0;  
		for (i = 0; i < integral.length; i++) {  
			p = integral.length - i - 1;  
			d = integral.substr(i, 1);  
			quotient = p / 4;  
			modulus = p % 4;  
			if (d == "0") {  
				zeroCount++;  
			}  
			else {  
				if (zeroCount > 0)  
				{  
					outputCharacters += digits[0];  
				}  
				zeroCount = 0;  
				outputCharacters += digits[Number(d)] + radices[modulus];  
			}  
			if (modulus == 0 && zeroCount < 4) {  
				outputCharacters += bigRadices[quotient];  
			}  
		}  
		outputCharacters += CN_DOLLAR;  
	}  
	// Process decimal part if there is:  
	if (decimal != "") {  
		for (i = 0; i < decimal.length; i++) {  
			d = decimal.substr(i, 1);  
			if (d != "0") {  
				outputCharacters += digits[Number(d)] + decimals[i];  
			}  
		}  
	}  
	// Confirm and return the final output string:  
	if (outputCharacters == "") {  
		outputCharacters = CN_ZERO + CN_DOLLAR;  
	}  
	if (decimal == "") {  
		outputCharacters += CN_INTEGER;  
	}  
	return outputCharacters;  
} 


//过滤表情
export function filteremoji(content) {
  var ranges = [
    "\ud83c[\udf00-\udfff]",
    "\ud83d[\udc00-\ude4f]",
    "\ud83d[\ude80-\udeff]",
  ];
  var emojireg = content.replace(new RegExp(ranges.join("|"), "g"), "");
  return emojireg;
}

//计算字节
export function countByte(s) {
  var len = 0;
  for (var i = 0; i < s.length; i++) {
    var c = s.charCodeAt(i);
    //单字节加1
    if ((c >= 0x0001 && c <= 0x007e) || (0xff60 <= c && c <= 0xff9f)) {
      len++;
    } else {
      len += 2;
    }
  }
  return len;
}

//加载js
export function loadScript(url, callback) {
  var script = document.createElement("script");
  script.type = "text/javascript";
  if (script.readyState) {
    script.onreadystatechange = function() {
      if (script.readyState == "loaded" || script.readyState == "complete") {
        script.onreadystatechange = null;
        callback();
      }
    };
  } else {
    script.onload = function() {
      callback();
    };
  }
  script.src = url;
  document.getElementsByTagName("head")[0].appendChild(script);
}

//过滤XSS攻击
export function escape(str) {
  return String(str)
    .replace(/&(?!\w+;)/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

//去掉2边空格
export function trim(str) {
  str = typeof str === "string" ? str : "";
  return str.trim ? str.trim() : str.replace(/^\s|\s$/g, "");
}

//获取IE版本
export function getIEVersion() {
  var ua = navigator.userAgent,
    matches,
    tridentMap = { "4": 8, "5": 9, "6": 10, "7": 11 };
  matches = ua.match(/MSIE (\d+)/i);
  if (matches && matches[1]) {
    return +matches[1];
  }
  matches = ua.match(/Trident\/(\d+)/i);
  if (matches && matches[1]) {
    return tridentMap[matches[1]] || null;
  }
  return null;
}

//检测浏览器，如果是ie7、ie6 显示提示升级浏览器信息
export function updateIE() {
  var browser = navigator.appName;
  if (browser == "Microsoft Internet Explorer") {
    var b_version = navigator.appVersion;
    var version = b_version.split(";");
    var trim_Version = version[1].replace(/[ ]/g, "");
    if (trim_Version == "MSIE7.0" || trim_Version == "MSIE6.0") {
      window.location.href = "../../system/ie.html";
    }
  }
}

//是否是PC端
export function isPc() {
  var userAgentInfo = navigator.userAgent;
  var Agents = new Array(
    "Android",
    "iPhone",
    "SymbianOS",
    "Windows Phone",
    "iPad",
    "iPod"
  );
  var flag = true;
  for (var v = 0; v < Agents.length; v++) {
    if (userAgentInfo.indexOf(Agents[v]) > 0) {
      flag = false;
      break;
    }
  }
  return flag;
}

export function getUrlParam(name) {
  var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
  var r = window.location.search.substr(1).match(reg);
  if (r != null) return decodeURI(r[2]);
  //if (r != null) return unescape(r[2]);
  return null;
}



/*
-------------------------------------------------------
base64加密解密
-------------------------------------------------------
var _base64 = function(){

    var self = this;

    // private property
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    // public method for encoding
    this.encode = function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = self._utf8_encode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output +
                _keyStr.charAt(enc1) + _keyStr.charAt(enc2) +
                _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output;
    }

    // public method for decoding
    this.decode = function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }
        }
        output = self._utf8_decode(output);
        return output;
    }

    // private method for UTF-8 encoding
    this._utf8_encode = function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }
        return utftext;
    }

    // private method for UTF-8 decoding
    this._utf8_decode = function (utftext) {
        var string = "";
        var i = 0;
        var c = 0;
        var c1 = 0;
        var c2 = 0;
        var c3 = 0;
        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            } else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            } else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }
        return string;
    }
};
//base64加密
function encrypt(str){
	var base64 = new _base64();
    var encrypt = base64.encode(str);
    return encrypt;
}
//base64解密
function decrypt(str){
	var base64 = new _base64();
    var decrypt = base64.decode(str);
    decrypt = escape(decrypt);
    decrypt = decrypt.replace(/%00/g, '');
    decrypt = unescape(decrypt);
    return decrypt;
}
*/

/*
-------------------------------------------------------
解决不支持Object.create
-------------------------------------------------------
if (!Object.create) {
    Object.create = function(o, properties) {
        if (typeof o !== 'object' && typeof o !== 'function') throw new TypeError('Object prototype may only be an Object: ' + o);
    else if (o === null) throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");

    if (typeof properties != 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");

        function F() {}

        F.prototype = o;

        return new F();
    };
}

(function() {
	var testObject = {};
	if (!(Object.setPrototypeOf || testObject.__proto__)) {
		var nativeGetPrototypeOf = Object.getPrototypeOf;

		Object.getPrototypeOf = function(object) {
			if (object.__proto__) {
				return object.__proto__;
			} else {
				return nativeGetPrototypeOf.call(Object, object);
			}
		}
	}
})();
*/


/* eslint-disable no-empty */
/* eslint-disable no-unused-vars */
//验证是否是url
export function isUrl(str) {
  return /(http|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?/.test(
    str
  );
}

//是否是微信客户端
export function isWx() {
  var ua = navigator.userAgent.toLowerCase();
  if (ua.match(/MicroMessenger/i) == "micromessenger") {
    return true;
  } else {
    return false;
  }
}

//是否存在指定函数
export function isExitsFunction(funcName) {
  try {
    if (typeof eval(funcName) == "function") {
      return true;
    }
  } catch (e) {}
  return false;
}
//是否存在指定变量
export function isExitsVariable(variableName) {
  try {
    if (typeof variableName == "undefined") {
      //alert("value is undefined");
      return false;
    } else {
      //alert("value is true");
      return true;
    }
  } catch (e) {}
  return false;
}

/**
 * 验证是不是邮件.
 * @param {要验证的字符串} strEmail
 * @return {Boolean}
 */

function _isEmail(strEmail) {
  //接下来的验证是否有两个以上的‘.’号，有的话就是错的！
  var first = strEmail.indexOf(".");
  if (strEmail.indexOf("@") == -1) {
    return false;
  }
  var tempStr = strEmail.substring(first + 1);
  if (tempStr.indexOf(".") != -1) {
    return false;
  }
  if (
    strEmail.search(
      /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
    ) != -1
  ) {
    return true;
  } else return false;
}

/**
 * @param {string} email
 * @returns {Boolean}
 */
export function validEmail(email) {
  const reg = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return reg.test(email);
}
/**
 * @param {string} url
 * @returns {Boolean}
 */
export function validURL(url) {
  const reg = /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?'\\+&%$#=~_-]+))*$/;
  return reg.test(url);
}

```


```js


/**
 * Parse the time to string
 * @param {(Object|string|number)} time
 * @param {string} cFormat
 * @returns {string | null}
 */
export function parseTime(time, cFormat) {
  if (arguments.length === 0 || !time) {
    return null;
  }
  const format = cFormat || "{y}-{m}-{d} {h}:{i}:{s}";
  let date;
  if (typeof time === "object") {
    date = time;
  } else {
    if (typeof time === "string") {
      if (/^[0-9]+$/.test(time)) {
        // support "1548221490638"
        time = parseInt(time);
      } else {
        // support safari
        // https://stackoverflow.com/questions/4310953/invalid-date-in-safari
        time = time.replace(new RegExp(/-/gm), "/");
      }
    }

    if (typeof time === "number" && time.toString().length === 10) {
      time = time * 1000;
    }
    date = new Date(time);
  }
  const formatObj = {
    y: date.getFullYear(),
    m: date.getMonth() + 1,
    d: date.getDate(),
    h: date.getHours(),
    i: date.getMinutes(),
    s: date.getSeconds(),
    a: date.getDay(),
  };
  const time_str = format.replace(/{([ymdhisa])+}/g, (result, key) => {
    const value = formatObj[key];
    // Note: getDay() returns 0 on Sunday
    if (key === "a") {
      return ["日", "一", "二", "三", "四", "五", "六"][value];
    }
    return value.toString().padStart(2, "0");
  });
  return time_str;
}

/**
 * @param {number} time
 * @param {string} option
 * @returns {string}
 */
export function formatTime(time, option) {
  if (("" + time).length === 10) {
    time = parseInt(time) * 1000;
  } else {
    time = +time;
  }
  const d = new Date(time);
  const now = Date.now();

  const diff = (now - d) / 1000;

  if (diff < 30) {
    return "刚刚";
  } else if (diff < 3600) {
    // less 1 hour
    return Math.ceil(diff / 60) + "分钟前";
  } else if (diff < 3600 * 24) {
    return Math.ceil(diff / 3600) + "小时前";
  } else if (diff < 3600 * 24 * 2) {
    return "1天前";
  }
  if (option) {
    return parseTime(time, option);
  } else {
    return (
      d.getMonth() +
      1 +
      "月" +
      d.getDate() +
      "日" +
      d.getHours() +
      "时" +
      d.getMinutes() +
      "分"
    );
  }
}
```


### 防抖节流
```js
/**
 * @description                       将函数转成防抖动函数
 * @param  {Function}                 需要转成防抖动函数的函数
 * @param  {number}                   延迟时间（毫秒数）
 * @param  {boolean}                  是否执行第一次
 * @return {undefined}                无返回值
 */
export function debounce(fn, delay = 600, runFirstFn = true) {
  let timer = null;

  return function (...rest) {
    // 清除定时器
    clearTimeout(timer);
    if (runFirstFn) {
      fn.apply(this, rest);
      runFirstFn = false;
      return;
    }

    // 设置定时器
    timer = setTimeout(fn.bind(this, ...rest), delay);
  };
}


// 防抖 且首次执行
// 采用原理：第一操作触发，连续操作时，最后一次操作打开任务开关（并非执行任务），任务将在下一次操作时触发）
export function debounceStart(fn, delay, ctx) {
  let immediate = true 
  let movement = null
  return function() {
      let args = arguments
      
      // 开关打开时，执行任务
      if (immediate) {
          fn.apply(ctx, args)
          immediate = false
      }
      // 清空上一次操作
      clearTimeout(movement)
      
      // 任务开关打开
      movement = setTimeout(function() {
          immediate = true
      }, delay)
  }
}

// 防抖 尾部执行
// 采用原理：连续操作时，上次设置的setTimeout被clear掉
export function debounceTail(fn, delay, ctx) {
  let movement = null
  return function() {
      let args = arguments
      
      // 清空上一次操作
      clearTimeout(movement)
      
      // delay时间之后，任务执行
      movement = setTimeout(function() {
          fn.apply(ctx, args)
      }, delay)
  }
}

// 限频，每delay的时间执行一次 
export function throttle(fn, delay, ctx) {
  let isAvail = true
  return function() {
      let args = arguments
      
      // 开关打开时，执行任务
      if (isAvail) {
          fn.apply(ctx, args)
          isAvail = false
          
          // delay时间之后，任务开关打开
          setTimeout(function() {
              isAvail = true
          }, delay)
      }
  }
}
```