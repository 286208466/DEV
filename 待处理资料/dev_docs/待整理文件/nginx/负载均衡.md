### nginx  

Nginx 是开源的轻量级 Web 服务器、反向代理服务器，以及负载均衡器和 HTTP 缓存器。其特点是高并发，高性能和低内存  

### 负载均衡  

负载均衡（Load Balance），它在网络现有结构之上可以提供一种廉价、有效、透明的方法来扩展网络设备和服务器的带宽，并可以在一定程度上增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性等。用官网的话说，它充当着网络流中“交通指挥官”的角色，“站在”服务器前处理所有服务器端和客户端之间的请求，从而最大程度地提高响应速率和容量利用率，同时确保任何服务器都没有超负荷工作。如果单个服务器出现故障，负载均衡的方法会将流量重定向到其余的集群服务器，以保证服务的稳定性。当新的服务器添加到服务器组后，也可通过负载均衡的方法使其开始自动处理客户端发来的请求。 

![负载均衡](/nginx/resources/images/fzjh.jpg)

### 正向代理  

![正向代理](/nginx/resources/images/zxdl.jpg)  

正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。  

![正向代理](/nginx/resources/images/zxdl2.jpg)  

例子：翻墙  

### 反向代理  

![反向代理](/nginx/resources/images/fxdl.jpg)  

反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证  

![反向代理](/nginx/resources/images/fxdl2.jpg)

### 负载均衡常用算法  

+ 1. 轮询 （round-robin）  

轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 $M$ 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。

特点：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。  

+ 2、加权轮询  

为了避免普通轮询带来的弊端，加权轮询应运而生。在加权轮询中，每个服务器会有各自的 weight 。一般情况下， weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。  

特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。  

Nginx 加权轮询源码可见： [ngx_http_upstream_round_robin.c ](https://github.com/nginx/nginx/blob/master/src/http/ngx_http_upstream_round_robin.c)，源码分析可参考： [关于轮询策略原理的自我理解](https://blog.csdn.net/BlacksunAcheron/article/details/84439302) 。其核心思想是，遍历各服务器节点，并计算节点权值，计算规则为 current_weight 与其对应的 effective_weight 之和，每轮遍历中选出权值最大的节点作为最优服务器节点。其中 effective_weight 会在算法的执行过程中随资源情况和响应情况而改变。较为核心的部分如下：  

    for (peer = rrp->peers->peer, i = 0;
        peer;     /* peer 为当前遍历的服务器结点*/
        peer = peer->next, i++)
    {
    ...

        /* 每轮遍历会更新 peer 当前的权值*/
        peer->current_weight += peer->effective_weight;

    ...

        /* best 为当前服务器中的最优节点，即本轮中选中的服务器节点*/
        if (best == NULL || peer->current_weight > best->current_weight) {
            best = peer;
        p = i;
        }

    ...
    }  

+ 3. IP 哈希（IP hash）  

ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。  

特点：该算法在一定程度上解决了集群部署环境下 session 不共享的问题。  

session 不共享问题是说，假设用户已经登录过，此时发出的请求被分配到了 A 服务器，但 A 服务器突然宕机，用户的请求则会被转发到 B 服务器。但由于 session 不共享，B 无法直接读取用户的登录信息来继续执行其他操作。  

实际应用中，我们可以利用 ip_hash ，将一部分 IP 下的请求转发到运行新版本服务的服务器，另一部分转发到旧版本服务器上，实现灰度发布。再者，如遇到文件过大导致请求超时的情况，也可以利用 ip_hash 进行文件的分片上传，它可以保证同客户端发出的文件切片转发到同一服务器，利于其接收切片以及后续的文件合并操作。  

+ 4、其他算法  

`URL hash`  

url_hash 是根据请求的 URL 的 hash 值来分配服务器。该算法的特点是，相同 URL 的请求会分配给固定的服务器，当存在缓存的时候，效率一般较高。然而 Nginx 默认不支持这种负载均衡算法，需要依赖第三方库。  

`最小连接数（Least Connections）`  

假设共有 $M$ 台服务器，当有新的请求出现时，遍历服务器节点列表并选取其中连接数最小的一台服务器来响应当前请求。连接数可以理解为当前处理的请求数。  
